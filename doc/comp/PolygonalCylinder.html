
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>PolygonalCylinder</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-12-22"><meta name="DC.source" content="PolygonalCylinder.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>PolygonalCylinder</h1><!--introduction--><p>Concrete subclass of <a href="GenericCylinder.html"><tt>GenericCylinder</tt></a> representing a cylinder with a polygonal cross section.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Description</a></li><li><a href="#2">Construction</a></li><li><a href="#3">Example</a></li><li><a href="#4">See Also</a></li></ul></div><h2>Description<a name="1"></a></h2><p><tt>PolygonalCylinder</tt> is a Shape for a cylinder whose cross section is a polygon.  It is assumed that the polygon is convex and the mean of its vertices is inside the polygon.  The axis of the cylinder should be aligned with one of the axes of the Cartesian coordinate system.</p><h2>Construction<a name="2"></a></h2><pre>shape = PolygonalCylinder(normal_axis, height, normal_center, point_array)
shape = PolygonalCylinder(normal_axis, height, normal_center, point_array, dl_max)</pre><p><b>Input Arguments</b></p><div><ul><li><tt>normal_axis</tt>: axis of the cylinder.  It should be one of <tt>Axis.x</tt>, <tt>Axis.y</tt>, <tt>Axis.z</tt>.</li><li><tt>height</tt>: size of the cylinder along its axis.</li><li><tt>normal_center</tt>: center of the axis of the cylinder.  It is a real number.</li><li><tt>radius</tt>: radius of the circle</li><li><tt>point_array</tt>: <tt>n</tt>-by-|2| array of the vertices of the polygon with <tt>n</tt> vertices.  For <tt>normal_axis == Axis.y</tt>, it is in the format of <tt>[z1 x1; ...; zn xn]</tt>.</li><li><tt>dl_max</tt>: maximum grid size allowed in the cylinder.  It can be either <tt>[dx dy dz]</tt> or a single real number <tt>dl</tt> for <tt>dx = dy = dz</tt>.  If unassigned, <tt>dl_max = Inf</tt> is used.</li></ul></div><h2>Example<a name="3"></a></h2><pre class="language-matlab"><span class="comment">% Create an instance of SectoralCylinder.</span>
shape = PolygonalCylinder(Axis.z, 100, 50, [0 0; 50 0; 25 25*sqrt(3)]);  <span class="comment">% cross section is regular triangle</span>
</pre><pre class="language-matlab"><span class="comment">% Use the constructed shape in maxwell_run().</span>
[E, H] = maxwell_run({INITIAL ARGUMENTS}, <span class="string">'OBJ'</span>, {<span class="string">'vacuum'</span>, <span class="string">'none'</span>, 1.0}, shape, {REMAINING ARGUMENTS});
</pre><h2>See Also<a name="4"></a></h2><p><a href="CircularCylinder.html"><tt>CircularCylinder</tt></a>, <a href="EllipticCylinder.html"><tt>EllipticCylinder</tt></a>, <a href="SectoralCylinder.html"><tt>SectoralCylinder</tt></a>, <a href="Shape.html"><tt>Shape</tt></a>, <a href="maxwell_run.html"><tt>maxwell_run</tt></a></p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% PolygonalCylinder
% Concrete subclass of <GenericCylinder.html |GenericCylinder|> representing a
% cylinder with a polygonal cross section.

%%% Description
% |PolygonalCylinder| is a Shape for a cylinder whose cross section is a
% polygon.  It is assumed that the polygon is convex and the mean of its
% vertices is inside the polygon.  The axis of the cylinder should be aligned
% with one of the axes of the Cartesian coordinate system.

%%% Construction
%  shape = PolygonalCylinder(normal_axis, height, normal_center, point_array)
%  shape = PolygonalCylinder(normal_axis, height, normal_center, point_array, dl_max)
% 
% *Input Arguments*
%
% * |normal_axis|: axis of the cylinder.  It should be one of |Axis.x|,
% |Axis.y|, |Axis.z|.
% * |height|: size of the cylinder along its axis.
% * |normal_center|: center of the axis of the cylinder.  It is a real number.
% * |radius|: radius of the circle
% * |point_array|: |n|-by-|2| array of the vertices of the polygon with |n|
% vertices.  For |normal_axis == Axis.y|, it is in the format of |[z1 x1; ...;
% zn xn]|.
% * |dl_max|: maximum grid size allowed in the cylinder.  It can be either |[dx
% dy dz]| or a single real number |dl| for |dx = dy = dz|.  If unassigned,
% |dl_max = Inf| is used.

%%% Example
%   % Create an instance of SectoralCylinder.
%   shape = PolygonalCylinder(Axis.z, 100, 50, [0 0; 50 0; 25 25*sqrt(3)]);  % cross section is regular triangle
%
%   % Use the constructed shape in maxwell_run().
%   [E, H] = maxwell_run({INITIAL ARGUMENTS}, 'OBJ', {'vacuum', 'none', 1.0}, shape, {REMAINING ARGUMENTS});

%%% See Also
% <CircularCylinder.html |CircularCylinder|>, <EllipticCylinder.html
% |EllipticCylinder|>, <SectoralCylinder.html |SectoralCylinder|>, <Shape.html
% |Shape|>, <maxwell_run.html |maxwell_run|>

classdef PolygonalCylinder < GenericCylinder

	methods
        function this = PolygonalCylinder(normal_axis, height, normal_center, point_array, dl_max)
			chkarg(istypesizeof(normal_axis, 'Axis'), '"normal_axis" should be instance of Axis.');
			chkarg(istypesizeof(height, 'real') && height > 0, '"height" should be positive.');
			chkarg(istypesizeof(normal_center, 'real'), '"normal_center" should be real.');
			chkarg(istypesizeof(point_array, 'real', [0 Dir.count]), ...
				'"point_array" should be %d-column matrix with real elements', Dir.count);

			Np = size(point_array, 1);
			p_array = point_array.';
			p_array = [p_array, p_array(:,1)];  % # of columns: Np+1
			c = mean(p_array, 2);
			pc_array = [p_array(1,:) - c(1); p_array(2,:) - c(2)];
			z_array = pc_array(1,:) + 1i * pc_array(2,:);
			theta_array = angle(z_array(2:end) ./ z_array(1:end-1));  % length: Np
			chkarg(all(theta_array > 0), ...
				'"point_array" should represent points arranged in counter-clockwise direction.');
			
			d_array = diff(p_array, [], 2);
			
			% Set up n_array, the array of outward unit vectors.
			n_array = [d_array(2,:); -d_array(1,:)];
			nn_array = sqrt(sum(n_array.^2));
			n_array = [n_array(1,:)./nn_array; n_array(2,:)./nn_array];  % # of columns: Np
			
			% Set up s_array, the array of distances from the center.
			s_array = sum(pc_array(:,1:end-1) .* n_array);  % length: Np
			chkarg(all(s_array > 0), 'mean point of vertices should be in polygon.');
			
			% lsf2d() can andle rho = [p q] with column vectors p and q.
			function level = lsf2d(rho)
				chkarg(istypesizeof(rho, 'real', [0, Dir.count]), ...
					'"rho" should be matrix with %d columns with real elements.', Dir.count);
				N = size(rho, 1);
				c_vec = repmat(c.', [N 1]);
				rc = rho - c_vec;
				rc = repmat(rc, [1 1 Np]);
				n_array_vec = reshape(n_array, [1 Dir.count Np]);
				n_array_vec = repmat(n_array_vec, [N 1]);
				s_array_vec = reshape(s_array, [1 1 Np]);
				s_array_vec = repmat(s_array_vec, [N 1]);
				level = 1 - max(sum(rc .* n_array_vec, 2) ./s_array_vec, [], 3);
			end

			[h, v, n] = cycle(normal_axis);
			lprim = cell(1, Axis.count);
			lprim{h} = p_array(1, 1:end-1);
			lprim{v} = p_array(2, 1:end-1);
			lprim{n} = [-height height]/2 + normal_center;
			
			if nargin < 5  % no dl_max
				super_args = {normal_axis, @lsf2d, lprim};
			else
				super_args = {normal_axis, @lsf2d, lprim, dl_max};
			end
			
			this = this@GenericCylinder(super_args{:});
		end
	end
end


##### SOURCE END #####
--></body></html>